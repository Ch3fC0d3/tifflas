<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIFF‚ÜíLAS Digitizer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { opacity: 0.9; font-size: 1.1em; }
        .content { padding: 30px; }
        .step {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }
        .step h2 { color: #667eea; margin-bottom: 15px; }
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover { background: #f0f4ff; border-color: #764ba2; }
        .upload-area.dragover { background: #e0e7ff; border-color: #667eea; }
        #imagePreview {
            max-width: 100%;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin: 20px 0;
            cursor: crosshair;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .scroll-bottom-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            font-size: 14px;
            z-index: 999;
        }
        .curve-config {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .curve-config h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .status {
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 600;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        #overlay {
            position: relative;
            display: inline-block;
        }
        .track-box {
            position: absolute;
            border: 3px solid #00ff00;
            pointer-events: none;
        }
        .hidden { display: none; }
        .curve-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .curve-checkboxes label {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #eef2ff;
            border: 1px solid #cbd5ff;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.9em;
        }
        .hint-text {
            font-size: 0.85em;
            color: #555;
        }
        .phrase-highlight {
            position: absolute;
            border: 2px solid #ef4444;
            background: rgba(248, 113, 113, 0.25);
            pointer-events: none;
        }
        .primary-region-overlay {
            position: absolute;
            border: 2px solid #3b82f6; /* blue */
            background: rgba(59, 130, 246, 0.15);
            pointer-events: none;
            z-index: 20;
        }
        .ai-track-overlay {
            position: absolute;
            border: 2px dashed #f97316; /* orange */
            background: rgba(249, 115, 22, 0.12);
            pointer-events: none;
            z-index: 18;
        }
        .panel-mask-overlay {
            position: absolute;
            background: #ffffff;
            opacity: 0.96;
            pointer-events: none;
            z-index: 10;
        }
        .auto-corrected {
            background-color: #fff3cd !important;
            border-color: #ffc107 !important;
            transition: background-color 0.3s ease;
        }
        .label-overlay {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #ff9800;
            background-color: rgba(255, 152, 0, 0.2);
            pointer-events: auto;
        }
        .depth-overlay-line {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px dashed rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }
        .ai-depth-hint-line {
            border-top: 2px solid #10b981; /* teal */
        }
        .ai-depth-hint-label {
            font-weight: 600;
            color: #047857;
        }
        .depth-overlay-label {
            position: absolute;
            left: 0;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.85);
            padding: 1px 4px;
            font-size: 10px;
            color: #333;
        }
        .intro-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .intro-backdrop.hidden {
            display: none;
        }
        .intro-modal {
            max-width: 600px;
            width: 90%;
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.35);
            padding: 20px 24px;
        }
        .intro-modal h2 {
            margin-bottom: 10px;
            color: #4c51bf;
        }
        .intro-modal p {
            margin-bottom: 8px;
            font-size: 0.95em;
            color: #333;
        }
        .intro-modal ol {
            margin-left: 20px;
            margin-bottom: 10px;
        }
        .intro-modal li {
            margin-bottom: 6px;
            font-size: 0.9em;
        }
        .intro-modal-actions {
            margin-top: 10px;
            text-align: right;
        }
        .intro-modal-close {
            border: none;
            background: transparent;
            color: #666;
            float: right;
            font-size: 18px;
            cursor: pointer;
        }
        .curve-trace-dot {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(56, 189, 248, 0.9); /* cyan */
            pointer-events: none;
        }
        .version-footer {
            margin-top: 8px;
            text-align: center;
            font-size: 11px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="introModalBackdrop" class="intro-backdrop hidden">
        <div class="intro-modal">
            <button type="button" class="intro-modal-close" onclick="closeIntroModal()" aria-label="Close">√ó</button>
            <h2>Welcome to TIFF‚ÜíLAS Digitizer</h2>
            <p>This tool converts well log images (TIFF/PNG/JPG) into QuickSyn-style LAS 1.2 files. The AI suggests defaults, but you stay in control.</p>
            <ol>
                <li><strong>Upload image:</strong> Drop or choose your log in Step 1. The preview appears in Step 2.</li>
                <li><strong>Depth setup:</strong> Use <em>Set top/bottom from image</em> and click on the depth scale on the image. The AI snaps to nearby depth labels and fills pixels and depth values.</li>
                <li><strong>Curves:</strong> In Step 3, pick curve types, left/right pixels, and scale values. AI uses track detection, color, and OCR labels to prefill suggestions, but you can edit everything.</li>
                <li><strong>Digitize:</strong> Click <em>Digitize &amp; Download LAS</em>. The app generates a QuickSyn-compatible LAS file (with 0.5 ft sampling when depth unit is Feet), runs basic checks, and shows depth/curve sanity warnings so you can review before using the file. For QuickSyn workflows, leave depth unit as <em>Feet (FT)</em>.</li>
                <li><strong>Review AI hints:</strong> Step 4 shows what the AI saw (e.g. header text like "SONIC DT" and sample values) to help you judge if its guesses make sense.</li>
            </ol>
            <p style="font-size: 0.85em; color: #555;">Tip: The AI never overwrites your choices. Treat suggestions as starting points, especially for depth anchors and curve labels.</p>
            <p style="font-size: 0.85em; color: #555; margin-top: 4px;">More details (QuickSyn expectations, examples, troubleshooting):
                <a href="https://github.com/Ch3fC0d3/tifflas#readme" target="_blank" rel="noopener noreferrer">see the full README on GitHub</a>.
            </p>
            <div class="intro-modal-actions">
                <button type="button" class="btn" style="padding: 8px 16px; font-size: 0.9em;" onclick="closeIntroModal()">Got it</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üéØ TIFF‚ÜíLAS Digitizer</h1>
            <p>Upload your well log image and digitize curves automatically</p>
            <button type="button" class="btn" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9em;" onclick="openIntroModal()">‚ùì How to use this tool</button>
        </div>

        <div class="content">
            <button type="button" class="btn scroll-bottom-btn" onclick="scrollToBottom()">‚¨á Scroll to bottom</button>
            <!-- Step 1: Upload -->
            <div class="step">
                <h2>Step 1: Upload Image</h2>
                <div class="upload-area" id="uploadArea">
                    <p>üìÅ Drag & drop your TIFF/PNG/JPG here or click to browse</p>
                    <p style="font-size: 0.9em; color: #666; margin-top: 10px;">‚ö†Ô∏è Max file size: 100MB</p>
                    <input type="file" id="fileInput" accept="image/*" style="display:none">
                </div>
                <div id="imageInfo" class="hidden"></div>
            </div>

            <!-- Step 2: Image Preview -->
            <div class="step hidden" id="previewStep">
                <h2>Step 2: Image Preview</h2>
                <p style="color: #666; margin-top: 10px;">
                    üìê Image dimensions: <span id="imageDims"></span>
                </p>
                <p id="mousePixelReadout" style="color: #666; font-size: 0.85em; margin-top: 4px;">
                    Mouse pixel: (move over image)
                </p>
                <p style="color: #666; font-size: 0.85em; margin-top: 6px;">
                    Tip: Use <strong>Set top/bottom from image</strong> and then click on the depth scale in the image to anchor your depth.
                </p>
                <div class="form-group" style="margin-top: 10px; max-width: 420px;">
                    <label for="phraseSearch">Jump to label (OCR)</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="phraseSearch" placeholder="e.g. GAMMA RAY" style="flex: 1;">
                        <button type="button" class="btn" style="padding: 6px 12px; font-size: 0.85em;" onclick="handlePhraseSearch()">Find</button>
                    </div>
                </div>
                <div class="form-group" style="margin-top: 8px; max-width: 420px;">
                    <label>Select log panel</label>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-top: 4px;">
                        <button type="button" class="btn" style="padding: 6px 12px; font-size: 0.85em;" onclick="beginPanelSelection()">Select panel from image</button>
                        <button type="button" class="btn" style="padding: 6px 12px; font-size: 0.85em;" onclick="clearPanelSelection()">Clear selection</button>
                    </div>
                    <div class="hint-text" id="selectionSummary">No panel selected. Using full image width and depth.</div>
                    <div class="hint-text">Click and drag directly on the image to draw a selection box around the log copy you want to digitize.</div>
                </div>
                <div id="overlay" style="margin-top: 14px;">
                    <img id="imagePreview" alt="Log preview">
                </div>
            </div>

            <!-- Step 3: Configuration -->
            <div class="step hidden" id="configStep">
                <h2>Step 3: Configure Digitization</h2>
                
                <div class="form-group">
                    <label>Depth Configuration</label>
                    <div class="curve-checkboxes" style="margin-top: 8px; margin-bottom: 8px;">
                        <button type="button" class="btn" style="padding: 6px 12px; font-size: 0.85em;" onclick="setDepthAnchorMode('top')">Set top from image</button>
                        <button type="button" class="btn" style="padding: 6px 12px; font-size: 0.85em;" onclick="setDepthAnchorMode('bottom')">Set bottom from image</button>
                    </div>
                    <div class="grid">
                        <div class="field">
                            <label for="topPx">Top pixel (Y)</label>
                            <input type="number" id="topPx" placeholder="Top pixel (Y)">
                        </div>
                        <div class="field">
                            <label for="bottomPx">Bottom pixel (Y)</label>
                            <input type="number" id="bottomPx" placeholder="Bottom pixel (Y)">
                        </div>
                        <div class="field">
                            <label for="topDepth">Top depth value</label>
                            <input type="number" id="topDepth" placeholder="Top depth value" step="0.1">
                        </div>
                        <div class="field">
                            <label for="bottomDepth">Bottom depth value</label>
                            <input type="number" id="bottomDepth" placeholder="Bottom depth value" step="0.1">
                        </div>
                        <div class="field">
                            <label for="depthUnit">Depth unit</label>
                            <select id="depthUnit">
                                <option value="FT">Feet (FT)</option>
                                <option value="M">Meters (M)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Number of Curves (max 6)</label>
                    <input type="number" id="numCurves" value="3" min="1" max="6">
                    <button class="btn" onclick="generateCurveInputs()" style="margin-top: 10px;">Generate Curve Fields</button>
                    <button class="btn" type="button" onclick="autoFillCurveTypes()" style="margin-top: 10px; margin-left: 8px;">‚ú® Auto-fill curve types</button>
                    <button class="btn" type="button" onclick="aiCalibratePanel()" style="margin-top: 10px; margin-left: 8px;">‚≠ê AI calibrate panel</button>
                    <button class="btn" type="button" onclick="aiDetectTracks()" style="margin-top: 10px; margin-left: 8px;">ü§ñ AI detect tracks</button>
                    <div class="hint-text" style="margin-top: 4px;">Uses scale ranges (GR/RHOB/NPHI/DT) to guess curve types for each track; you can still edit them.</div>
                    <div class="hint-text" style="margin-top: 4px;">Uses Vision + LLM to propose depth axis and all track calibrations from the selected panel; you can still edit them.</div>
                </div>

                <div id="curvesContainer"></div>
                <div id="curveScaleSummary" class="hint-text" style="margin-top: 8px;"></div>

                <button class="btn" onclick="runDigitization()" id="digitizeBtn" style="margin-top: 20px;">
                    üöÄ Digitize & Download LAS
                </button>
            </div>

            <!-- Status Messages -->
            <div id="statusArea"></div>

            <!-- Step 4: AI Insights -->
            <div class="step hidden" id="insightsStep">
                <h2>Step 4: AI Insights</h2>
                <div id="aiInsightContent" class="insight-card">
                    <p>Upload a log image to see Vision OCR suggestions here.</p>
                </div>
                <div class="insight-card" style="margin-top: 12px;">
                    <h3>Ask AI about this log</h3>
                    <p class="hint-text">The AI sees OCR text and LAS curve statistics for this image. You can ask things like "Which curve is GR vs DT?" or "Do any curves look unreasonable?"</p>
                    <textarea id="aiChatQuestion" rows="3" style="width: 100%; margin-top: 6px;" placeholder="Type a question about the current log (after running Digitize)..."></textarea>
                    <button type="button" class="btn" style="margin-top: 6px;" onclick="askAiAboutLog()">Ask AI</button>
                    <button type="button" class="btn" style="margin-top: 6px; margin-left: 8px;" onclick="askAiWhichCurveIsWhich()">Ask: which curve is which?</button>
                    <div id="aiChatOutput" style="margin-top: 8px;"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="version-footer">
        <span>Version: {{ app_version }} ‚Ä¢ Build: {{ build_time }}</span>
    </div>

    <script>
        let uploadedImage = null;
        let imageWidth = 0;
        let imageHeight = 0;
        let detectedTracks = [];
        let allTracks = [];
        let primaryRegion = null; // { left_px, right_px, track_indices }
        let ocrSuggestions = null;
        let detectedText = null;
        let depthAnchorMode = null; // 'top' | 'bottom' | null
        let panelSelectMode = false;
        let panelSelectStart = null; // { x, y } first corner of panel selection
        let primaryRegionDrag = { active: false, edge: null };
        let lastDigitizedDepth = null;   // array of depths from last /digitize
        let lastDigitizedCurves = null;  // { curveId: { unit, values[] } }

        // OCR phrase search state (Jump to label)
        let ocrSearchMatches = [];
        let ocrSearchIndex = -1;
        let ocrSearchPhrase = '';

        const DEPTH_SESSION_KEY = 'tifflas_depth_config_v1';
        const INTRO_SESSION_KEY = 'tifflas_intro_seen_v1';

        function openIntroModal() {
            const backdrop = document.getElementById('introModalBackdrop');
            if (backdrop) {
                backdrop.classList.remove('hidden');
            }
        }

        function closeIntroModal() {
            const backdrop = document.getElementById('introModalBackdrop');
            if (backdrop) {
                backdrop.classList.add('hidden');
            }
        }

        function setDepthAnchorMode(mode) {
            if (mode === 'top' || mode === 'bottom') {
                depthAnchorMode = mode;
            } else {
                depthAnchorMode = null;
            }
        }

        function beginPanelSelection() {
            panelSelectMode = true;
            panelSelectStart = null;
            primaryRegionDrag.active = false;
            primaryRegion = null;
            clearPrimaryRegionOverlay();
            showStatus('Click and drag on the image to draw a selection rectangle for the panel you want to digitize.', 'info');
            updateSelectionSummary();
        }

        function clearPanelSelection() {
            panelSelectMode = false;
            panelSelectStart = null;
            primaryRegionDrag.active = false;
            primaryRegionDrag.edge = null;
            primaryRegion = null;

            if (Array.isArray(allTracks)) {
                detectedTracks = allTracks.slice();
            }

            const topPxInput = document.getElementById('topPx');
            const bottomPxInput = document.getElementById('bottomPx');
            if (topPxInput && bottomPxInput && imageHeight) {
                topPxInput.value = 0;
                bottomPxInput.value = imageHeight - 1;
            }

            clearPrimaryRegionOverlay();
            renderDepthOverlays();

            autoConfigureCurves();
            generateCurveInputs();
            applyOcrSuggestions();
            renderAiInsights();
            updateSelectionSummary();
            showStatus('Cleared panel selection: using full image width and depth.', 'info');
        }

        function updateSelectionSummary() {
            const summaryEl = document.getElementById('selectionSummary');
            if (!summaryEl) return;

            if (!imageWidth || !imageHeight) {
                summaryEl.textContent = 'No image loaded.';
                return;
            }

            const topPxInput = document.getElementById('topPx');
            const bottomPxInput = document.getElementById('bottomPx');
            const topVal = topPxInput ? parseFloat(topPxInput.value) : NaN;
            const bottomVal = bottomPxInput ? parseFloat(bottomPxInput.value) : NaN;

            const hasRegion = primaryRegion &&
                Number.isFinite(Number(primaryRegion.left_px)) &&
                Number.isFinite(Number(primaryRegion.right_px)) &&
                Number(primaryRegion.right_px) > Number(primaryRegion.left_px);

            const usingFullDepth = !Number.isFinite(topVal) || !Number.isFinite(bottomVal) ||
                (Math.round(topVal) <= 0 && Math.round(bottomVal) >= imageHeight - 1);

            const trackCount = Array.isArray(detectedTracks) ? detectedTracks.length : 0;

            if (!hasRegion && usingFullDepth) {
                summaryEl.textContent = 'No panel selected. Using full image width and depth.';
                return;
            }

            const regionPart = hasRegion
                ? `X: ${Math.round(primaryRegion.left_px)}‚Äì${Math.round(primaryRegion.right_px)}`
                : 'full width';

            const depthPart = (Number.isFinite(topVal) && Number.isFinite(bottomVal))
                ? `Y: ${Math.round(topVal)}‚Äì${Math.round(bottomVal)}`
                : 'full depth';

            summaryEl.textContent = `Panel: ${regionPart}, ${depthPart} ‚Ä¢ Tracks in use: ${trackCount}`;
        }

        function snapDepthToLabels(yImg) {
            if (!ocrSuggestions || !ocrSuggestions.depth_labels || !ocrSuggestions.depth_labels.length) {
                return null;
            }
            let best = null;
            let bestDy = null;
            for (const label of ocrSuggestions.depth_labels) {
                const yLabel = Number(label.y_px);
                if (!Number.isFinite(yLabel)) continue;
                const dy = Math.abs(yLabel - yImg);
                if (best === null || dy < bestDy) {
                    best = label;
                    bestDy = dy;
                }
            }
            if (!best) return null;
            const maxSnap = imageHeight ? Math.max(40, imageHeight * 0.02) : 40;
            if (bestDy > maxSnap) return null;
            const snappedY = Math.round(Number(best.y_px));
            const snappedDepth = Number(best.depth);
            if (!Number.isFinite(snappedY) || !Number.isFinite(snappedDepth)) return null;
            return { y_px: snappedY, depth: snappedDepth };
        }

        function getDepthConfigFromInputs() {
            const topPxVal = parseFloat(document.getElementById('topPx').value);
            const bottomPxVal = parseFloat(document.getElementById('bottomPx').value);
            const topDepthVal = parseFloat(document.getElementById('topDepth').value);
            const bottomDepthVal = parseFloat(document.getElementById('bottomDepth').value);
            const unitVal = document.getElementById('depthUnit').value;
            if (!Number.isFinite(topPxVal) || !Number.isFinite(bottomPxVal) ||
                !Number.isFinite(topDepthVal) || !Number.isFinite(bottomDepthVal)) {
                return null;
            }
            return {
                top_px: topPxVal,
                bottom_px: bottomPxVal,
                top_depth: topDepthVal,
                bottom_depth: bottomDepthVal,
                unit: unitVal
            };
        }

        function pixelToDepthFromConfig(yImg, depthCfg) {
            if (!depthCfg) return null;
            const topPx = Number(depthCfg.top_px);
            const bottomPx = Number(depthCfg.bottom_px);
            const topDepth = Number(depthCfg.top_depth);
            const bottomDepth = Number(depthCfg.bottom_depth);
            if (!Number.isFinite(topPx) || !Number.isFinite(bottomPx) ||
                !Number.isFinite(topDepth) || !Number.isFinite(bottomDepth) ||
                bottomPx === topPx) {
                return null;
            }
            const frac = (yImg - topPx) / (bottomPx - topPx);
            return topDepth + frac * (bottomDepth - topDepth);
        }

        function pixelToTrackValue(xImg, track) {
            if (!track) return null;
            const leftX = track.leftX;
            const rightX = track.rightX;
            const scaleMin = track.scaleMin;
            const scaleMax = track.scaleMax;
            const denom = rightX - leftX;
            if (!Number.isFinite(leftX) || !Number.isFinite(rightX) ||
                !Number.isFinite(scaleMin) || !Number.isFinite(scaleMax) ||
                Math.abs(denom) < 1e-3) {
                return null;
            }
            const frac = (xImg - leftX) / denom;
            return scaleMin + frac * (scaleMax - scaleMin);
        }

        function valueAtDepth1D(depth, depths, values) {
            if (!Array.isArray(depths) || !Array.isArray(values) ||
                depths.length !== values.length || depths.length === 0) {
                return null;
            }
            const first = depths[0], last = depths[depths.length - 1];
            const minD = Math.min(first, last);
            const maxD = Math.max(first, last);
            if (!Number.isFinite(depth) || depth < minD || depth > maxD) return null;

            let lo = 0, hi = depths.length - 1;
            const ascending = first <= last;
            while (hi - lo > 1) {
                const mid = (lo + hi) >> 1;
                const dMid = depths[mid];
                if ((ascending && dMid < depth) || (!ascending && dMid > depth)) lo = mid;
                else hi = mid;
            }
            const d0 = depths[lo], d1 = depths[hi];
            const v0 = values[lo], v1 = values[hi];
            const denom = d1 - d0;
            if (!Number.isFinite(denom) || Math.abs(denom) < 1e-6) return v0;
            const t = (depth - d0) / denom;
            return v0 + t * (v1 - v0);
        }

        function getTrackCalibrationsSnapshot() {
            const numCurvesInput = document.getElementById('numCurves');
            const numCurves = numCurvesInput ? (parseInt(numCurvesInput.value) || 0) : 0;
            const tracks = [];
            for (let i = 0; i < numCurves; i++) {
                const leftPxEl = document.getElementById(`leftPx${i}`);
                const rightPxEl = document.getElementById(`rightPx${i}`);
                const leftValEl = document.getElementById(`leftVal${i}`);
                const rightValEl = document.getElementById(`rightVal${i}`);
                if (!leftPxEl || !rightPxEl || !leftValEl || !rightValEl) continue;

                const leftX = parseFloat(leftPxEl.value);
                const rightX = parseFloat(rightPxEl.value);
                const scaleMin = parseFloat(leftValEl.value);
                const scaleMax = parseFloat(rightValEl.value);
                if (!Number.isFinite(leftX) || !Number.isFinite(rightX) ||
                    !Number.isFinite(scaleMin) || !Number.isFinite(scaleMax) ||
                    rightX <= leftX) {
                    continue;
                }

                const typeEl = document.getElementById(`type${i}`);
                const nameEl = document.getElementById(`name${i}`);
                const lasMnemonicEl = document.getElementById(`lasMnemonic${i}`);
                const unitEl = document.getElementById(`unit${i}`);
                const lasUnitEl = document.getElementById(`lasUnit${i}`);

                const id = (lasMnemonicEl && lasMnemonicEl.value
                    ? lasMnemonicEl.value.trim()
                    : (typeEl && typeEl.value ? typeEl.value : `CURVE${i + 1}`));

                tracks.push({
                    id: id.toUpperCase(),
                    index: i,
                    name: typeEl && typeEl.value ? typeEl.value : id,
                    displayName: nameEl && nameEl.value ? nameEl.value : '',
                    leftX,
                    rightX,
                    scaleMin,
                    scaleMax,
                    displayUnit: unitEl && unitEl.value ? unitEl.value : '',
                    lasUnit: lasUnitEl && lasUnitEl.value ? lasUnitEl.value : ''
                });
            }
            return tracks;
        }

        function saveDepthConfigToSession() {
            try {
                const cfg = getDepthConfigFromInputs();
                if (!cfg) return;
                sessionStorage.setItem(DEPTH_SESSION_KEY, JSON.stringify(cfg));
            } catch (e) {
                // ignore storage errors
            }
        }

        function loadDepthConfigFromSession() {
            try {
                const raw = sessionStorage.getItem(DEPTH_SESSION_KEY);
                if (!raw) return false;
                const cfg = JSON.parse(raw);
                if (!cfg) return false;
                const topPxInput = document.getElementById('topPx');
                const bottomPxInput = document.getElementById('bottomPx');
                const topDepthInput = document.getElementById('topDepth');
                const bottomDepthInput = document.getElementById('bottomDepth');
                const depthUnit = document.getElementById('depthUnit');
                if (!topPxInput || !bottomPxInput || !topDepthInput || !bottomDepthInput || !depthUnit) {
                    return false;
                }
                if (Number.isFinite(cfg.top_px)) topPxInput.value = cfg.top_px;
                if (Number.isFinite(cfg.bottom_px)) bottomPxInput.value = cfg.bottom_px;
                if (Number.isFinite(cfg.top_depth)) topDepthInput.value = cfg.top_depth;
                if (Number.isFinite(cfg.bottom_depth)) bottomDepthInput.value = cfg.bottom_depth;
                if (cfg.unit) depthUnit.value = cfg.unit;
                return true;
            } catch (e) {
                return false;
            }
        }

        const curveTypeDefaults = {
            GR:   { mnemonic: 'GR',   unit: 'API' },
            RHOB: { mnemonic: 'RHOB', unit: 'G/CC' },
            NPHI: { mnemonic: 'NPHI', unit: 'V/V' },
            DT:   { mnemonic: 'DTC',  unit: 'US/F' },
            DTC:  { mnemonic: 'DTC',  unit: 'US/F' },
            CALI: { mnemonic: 'CALI', unit: 'IN' },
            SP:   { mnemonic: 'SP',   unit: 'MV' }
        };

        (function initIntroModalOnce() {
            try {
                const seen = localStorage.getItem(INTRO_SESSION_KEY);
                if (!seen) {
                    openIntroModal();
                    localStorage.setItem(INTRO_SESSION_KEY, '1');
                }
            } catch (e) {
                // ignore localStorage issues
            }
        })();

        // Upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleFile(e.target.files[0]);
            }
        });

        // Depth anchor & panel/region interaction on image
        const imagePreview = document.getElementById('imagePreview');
        const mousePixelReadout = document.getElementById('mousePixelReadout');

        imagePreview.addEventListener('mousemove', (event) => {
            if (!mousePixelReadout) return;

            const rect = imagePreview.getBoundingClientRect();
            if (!rect.width || !rect.height) return;

            // Prefer the known imageWidth/imageHeight, but fall back to the
            // actual image element's dimensions so the readout still works
            // even if globals were not initialized for some reason.
            let w = imageWidth || imagePreview.naturalWidth || imagePreview.width;
            let h = imageHeight || imagePreview.naturalHeight || imagePreview.height;

            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if (!w || !h) {
                // As a last resort, still show approximate DOM coordinates.
                mousePixelReadout.textContent = `Mouse pixel: X‚âà${Math.round(x)}, Y‚âà${Math.round(y)}`;
                return;
            }

            // If globals were zero, lock them in now so all other logic
            // (depth, tracks) uses consistent image coordinates.
            if (!imageWidth || !imageHeight) {
                imageWidth = w;
                imageHeight = h;
            }

            const xNorm = x / rect.width;
            const yNorm = y / rect.height;
            const xImg = Math.round(xNorm * (imageWidth - 1));
            const yImg = Math.round(yNorm * (imageHeight - 1));

            const depthCfg = getDepthConfigFromInputs();
            const depth = pixelToDepthFromConfig(yImg, depthCfg);

            let text = `Mouse pixel: X=${xImg}, Y=${yImg}`;
            if (Number.isFinite(depth)) {
                const unit = depthCfg ? depthCfg.unit : '';
                text += ` ‚Ä¢ Depth: ${depth.toFixed(1)} ${unit}`;
            }

            // Find active track under cursor
            const tracks = getTrackCalibrationsSnapshot();
            let valueText = '';
            if (tracks && tracks.length && Number.isFinite(xImg)) {
                const activeTrack = tracks.find(t => xImg >= t.leftX && xImg <= t.rightX);
                if (activeTrack && Number.isFinite(depth)) {
                    let value = null;

                    // Prefer actual digitized curve if available
                    if (lastDigitizedDepth && lastDigitizedCurves &&
                        lastDigitizedCurves[activeTrack.id] &&
                        Array.isArray(lastDigitizedCurves[activeTrack.id].values)) {
                        value = valueAtDepth1D(
                            depth,
                            lastDigitizedDepth,
                            lastDigitizedCurves[activeTrack.id].values
                        );
                    }

                    // Fallback: use scale mapping even before digitization
                    if (value == null) {
                        value = pixelToTrackValue(xImg, activeTrack);
                    }

                    if (Number.isFinite(value)) {
                        const label = activeTrack.displayName || activeTrack.name || activeTrack.id;
                        const unit = activeTrack.lasUnit || activeTrack.displayUnit || '';
                        valueText = ` ‚Ä¢ ${label}: ${value.toFixed(2)}${unit ? ' ' + unit : ''}`;
                    }
                }
            }

            let suffix = '';
            if (depthAnchorMode === 'top') {
                suffix = ' ‚Ä¢ anchoring TOP';
            } else if (depthAnchorMode === 'bottom') {
                suffix = ' ‚Ä¢ anchoring BOTTOM';
            }

            mousePixelReadout.textContent = text + valueText + suffix;
        });

        // Marquee-style panel selection (click-drag-release)
        imagePreview.addEventListener('mousedown', (event) => {
            if (!imageWidth || !imageHeight) return;

            const rect = imagePreview.getBoundingClientRect();
            if (!rect.width || !rect.height) return;

            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const xNorm = x / rect.width;
            const yNorm = y / rect.height;
            const xImg = Math.round(xNorm * (imageWidth - 1));
            const yImg = Math.round(yNorm * (imageHeight - 1));

            if (panelSelectMode) {
                // Start a new marquee selection
                panelSelectStart = { x: xImg, y: yImg };
                primaryRegion = null;
                clearPrimaryRegionOverlay();
                primaryRegionDrag.active = true; // reuse flag simply as \"drag in progress\"
                primaryRegionDrag.edge = 'marquee';
                event.preventDefault();
                return;
            }

            // If not in panelSelectMode, just let depth anchors handle click in the separate handler
        });

        // Track marquee drag while mouse is down
        document.addEventListener('mousemove', (event) => {
            if (!primaryRegionDrag.active || primaryRegionDrag.edge !== 'marquee') return;
            if (!panelSelectMode || !panelSelectStart || !imageWidth || !imageHeight) return;

            const rect = imagePreview.getBoundingClientRect();
            if (!rect.width || !rect.height) return;

            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const xNorm = Math.max(0, Math.min(1, x / rect.width));
            const yNorm = Math.max(0, Math.min(1, y / rect.height));
            const xImg = Math.round(xNorm * (imageWidth - 1));
            const yImg = Math.round(yNorm * (imageHeight - 1));

            const left = Math.min(panelSelectStart.x, xImg);
            const right = Math.max(panelSelectStart.x, xImg);
            const top = Math.min(panelSelectStart.y, yImg);
            const bottom = Math.max(panelSelectStart.y, yImg);

            primaryRegion = { left_px: left, right_px: right, track_indices: [] };

            // Have the box control depth pixels as well
            const topPxInput = document.getElementById('topPx');
            const bottomPxInput = document.getElementById('bottomPx');
            if (topPxInput && bottomPxInput) {
                topPxInput.value = top;
                bottomPxInput.value = bottom;
            }

            renderDepthOverlays();
            renderPrimaryRegionOverlay();
            updateSelectionSummary();
        });

        document.addEventListener('mouseup', async () => {
            if (!primaryRegionDrag.active) return;

            // Finish marquee selection if that was in progress
            if (primaryRegionDrag.edge === 'marquee' && panelSelectMode && panelSelectStart && imageWidth && imageHeight) {
                primaryRegionDrag.active = false;
                const rect = imagePreview.getBoundingClientRect();
                if (!rect.width || !rect.height) {
                    primaryRegionDrag.edge = null;
                    return;
                }

                // Use the last known primaryRegion horizontally and full vertical extent from drag
                // Compute current mouse position as second corner
                // (We do a small trick: read mouse position from last move via DOM, but if unavailable we just keep existing primaryRegion.)

                // Derive vertical top/bottom from the drag start and current mouse location
                // For robustness we clamp into image coordinates again.
                const lastX = panelSelectStart.x;
                const lastY = panelSelectStart.y;
                const left = Number(primaryRegion.left_px);
                const right = Number(primaryRegion.right_px);

                if (!Number.isFinite(left) || !Number.isFinite(right) || right <= left) {
                    primaryRegionDrag.edge = null;
                    return;
                }

                // For vertical, approximate from panelSelectStart and depth inputs if present.
                const topPxInput = document.getElementById('topPx');
                const bottomPxInput = document.getElementById('bottomPx');
                let topPx = 0;
                let bottomPx = imageHeight - 1;
                if (topPxInput && bottomPxInput) {
                    const t = parseFloat(topPxInput.value);
                    const b = parseFloat(bottomPxInput.value);
                    if (Number.isFinite(t) && Number.isFinite(b) && b > t) {
                        topPx = t;
                        bottomPx = b;
                    }
                }

                // Filter tracks within horizontal band
                if (Array.isArray(allTracks) && allTracks.length) {
                    const selected = [];
                    for (const t of allTracks) {
                        if (!Array.isArray(t) || t.length < 2) continue;
                        const cx = 0.5 * (Number(t[0]) + Number(t[1]));
                        if (!Number.isFinite(cx)) continue;
                        if (cx >= left && cx <= right) selected.push(t);
                    }
                    detectedTracks = selected;
                }

                // Update depth pixels from current vertical extent (or keep previous if user prefers)
                if (topPxInput && bottomPxInput) {
                    topPxInput.value = topPx;
                    bottomPxInput.value = bottomPx;
                }

                panelSelectMode = false;
                panelSelectStart = null;
                primaryRegionDrag.edge = null;

                autoConfigureCurves();
                generateCurveInputs();

                // Ask backend to re-analyze just this panel region for OCR/AI hints
                try {
                    const body = {
                        image: uploadedImage,
                        region: {
                            left_px: left,
                            right_px: right,
                            top_px: topPx,
                            bottom_px: bottomPx
                        }
                    };
                    const resp = await fetch('/reanalyze_panel', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });
                    if (resp.ok) {
                        const data = await resp.json();
                        if (data.success) {
                            ocrSuggestions = data.ocr_suggestions || ocrSuggestions;
                            detectedText = data.detected_text || detectedText;
                            applyOcrSuggestions();
                            renderAiInsights();
                        }
                    }
                } catch (e) {
                    console.error('Panel re-analysis failed', e);
                }

                renderPrimaryRegionOverlay();
                renderDepthOverlays();
                updateSelectionSummary();
                showStatus(`Using ${detectedTracks.length || 0} tracks in selected panel.`, 'success');
                return;
            }

            primaryRegionDrag.active = false;
            primaryRegionDrag.edge = null;
        });

        imagePreview.addEventListener('mouseleave', () => {
            if (mousePixelReadout) {
                mousePixelReadout.textContent = 'Mouse pixel: (move over image)';
            }
        });

        imagePreview.addEventListener('click', (event) => {
            if (!imageWidth || !imageHeight) return;

            const rect = imagePreview.getBoundingClientRect();
            if (!rect.width || !rect.height) return;

            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const xNorm = x / rect.width;
            const yNorm = y / rect.height;
            const xImg = Math.round(xNorm * (imageWidth - 1));
            const yImg = Math.round(yNorm * (imageHeight - 1));

            // If we're in panelSelectMode, the click is ignored here because marquee uses mousedown/mouseup.
            if (panelSelectMode) {
                return;
            }

            if (!depthAnchorMode) return;

            const snapped = snapDepthToLabels(yImg);
            // Use the exact clicked pixel for depth anchors so overlays align
            const usedY = yImg;
            const snappedDepth = snapped ? snapped.depth : null;

            if (depthAnchorMode === 'top') {
                const topPxInput = document.getElementById('topPx');
                const topDepthInput = document.getElementById('topDepth');
                topPxInput.value = usedY;
                const existing = topDepthInput.value;
                if (snappedDepth != null && Number.isFinite(snappedDepth)) {
                    if (!existing) {
                        topDepthInput.value = snappedDepth;
                    }
                } else if (!existing) {
                    const depthVal = window.prompt('Enter top depth value for this point (same unit as selected):');
                    if (depthVal !== null && depthVal !== '') {
                        topDepthInput.value = depthVal;
                    }
                }
            } else if (depthAnchorMode === 'bottom') {
                const bottomPxInput = document.getElementById('bottomPx');
                const bottomDepthInput = document.getElementById('bottomDepth');
                bottomPxInput.value = usedY;
                const existing = bottomDepthInput.value;
                if (snappedDepth != null && Number.isFinite(snappedDepth)) {
                    if (!existing) {
                        bottomDepthInput.value = snappedDepth;
                    }
                } else if (!existing) {
                    const depthVal = window.prompt('Enter bottom depth value for this point (same unit as selected):');
                    if (depthVal !== null && depthVal !== '') {
                        bottomDepthInput.value = depthVal;
                    }
                }
            }

            depthAnchorMode = null;
            renderDepthOverlays();
        });

        async function handleFile(file) {
            // Check file size (100MB limit)
            const maxSize = 100 * 1024 * 1024; // 100MB in bytes
            if (file.size > maxSize) {
                showStatus(`‚ùå File too large (${(file.size / 1024 / 1024).toFixed(1)}MB). Please use an image smaller than 100MB.`, 'error');
                return;
            }
            
            showStatus('Uploading...', 'info');
            
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    uploadedImage = data.image;
                    imageWidth = data.width;
                    imageHeight = data.height;
                    allTracks = data.all_tracks || data.tracks || [];
                    detectedTracks = data.tracks || [];
                    primaryRegion = null;
                    ocrSuggestions = {};
                    detectedText = null;

                    // Show preview
                    const imgEl = document.getElementById('imagePreview');
                    imgEl.onload = () => {
                        clearPrimaryRegionOverlay();
                        renderLabelOverlays();
                        renderDepthOverlays();
                    };
                    imgEl.src = data.image;
                    document.getElementById('imageDims').textContent = `${imageWidth} √ó ${imageHeight} pixels`;
                    document.getElementById('previewStep').classList.remove('hidden');
                    document.getElementById('configStep').classList.remove('hidden');
                    
                    // Pre-fill with defaults then apply AI suggestions
                    document.getElementById('topPx').value = 0;
                    document.getElementById('bottomPx').value = imageHeight - 1;
                    document.getElementById('topDepth').value = 1000;
                    document.getElementById('bottomDepth').value = 2000;

                    autoConfigureCurves();
                    generateCurveInputs();
                    const appliedHints = applyOcrSuggestions();
                    const usedSessionDepth = loadDepthConfigFromSession();
                    const aiNote = appliedHints ? ' ‚ú® AI suggestions applied.' : '';
                    const sessionNote = usedSessionDepth ? ' (reused last depth setup this session)' : '';

                    showStatus(`‚úÖ Image loaded: ${imageWidth}√ó${imageHeight}px${aiNote}${sessionNote}`, 'success');
                    renderAiInsights();
                    renderDepthOverlays();
                    updateSelectionSummary();
                } else {
                    showStatus('‚ùå Error: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('‚ùå Upload failed: ' + error.message, 'error');
            }
        }

        function autoConfigureCurves() {
            let inferredCurves = detectedTracks.length;
            if (!inferredCurves && ocrSuggestions && ocrSuggestions.curves) {
                inferredCurves = ocrSuggestions.curves.length;
            }
            if (inferredCurves) {
                document.getElementById('numCurves').value = Math.min(6, Math.max(1, inferredCurves));
            }
        }

        function syncCurveTypeToLabels(curveIndex) {
            const typeEl = document.getElementById(`type${curveIndex}`);
            const lasMnemonicEl = document.getElementById(`lasMnemonic${curveIndex}`);
            const lasUnitEl = document.getElementById(`lasUnit${curveIndex}`);
            if (!typeEl || !lasMnemonicEl || !lasUnitEl) return;

            const typeVal = typeEl.value;
            const defaults = curveTypeDefaults[typeVal] || {};
            
            // Only sync LAS mnemonic and unit - NOT display name
            // Display name should be determined independently by AI/OCR
            if (defaults.mnemonic) {
                lasMnemonicEl.value = defaults.mnemonic;
            }
            if (defaults.unit) {
                lasUnitEl.value = defaults.unit;
            }
        }

        function applySuggestedType(curveIndex, suggestedType, isAutoFix = false) {
            const typeEl = document.getElementById(`type${curveIndex}`);
            if (!typeEl) return;
            typeEl.value = suggestedType;
            
            // Visual indicator for auto-corrected fields
            if (isAutoFix) {
                typeEl.classList.add('auto-corrected');
                setTimeout(() => {
                    typeEl.classList.remove('auto-corrected');
                }, 3000);
            }
            
            syncCurveTypeToLabels(curveIndex);
            // Don't call updateCurveScaleHints here if it's an auto-fix to avoid infinite loop
            if (!isAutoFix) {
                updateCurveScaleHints();
            }
        }

        function autoFillCurveTypes() {
            const container = document.getElementById('curvesContainer');
            if (container && !container.children.length) {
                generateCurveInputs();
            }
            updateCurveScaleHints(true);
            generateValidationReport();
            showStatus('Auto-filled curve types based on scale ranges. Please review before digitizing.', 'info');
        }

        async function aiCalibratePanel() {
            if (!uploadedImage || !imageWidth || !imageHeight) {
                showStatus('Please upload an image first.', 'info');
                return;
            }

            if (!primaryRegion || !Number.isFinite(primaryRegion.left_px) || !Number.isFinite(primaryRegion.right_px)) {
                showStatus('Please select a panel first (click "Select panel from image" and drag a box).', 'info');
                return;
            }

            const topPxInput = document.getElementById('topPx');
            const bottomPxInput = document.getElementById('bottomPx');
            const topPx = topPxInput ? parseFloat(topPxInput.value) : 0;
            const bottomPx = bottomPxInput ? parseFloat(bottomPxInput.value) : imageHeight - 1;

            if (!Number.isFinite(topPx) || !Number.isFinite(bottomPx) || bottomPx <= topPx) {
                showStatus('Invalid depth pixel range; please select a panel first.', 'info');
                return;
            }

            showStatus('‚è≥ Asking AI to calibrate panel (Vision + LLM)...', 'info');

            try {
                const resp = await fetch('/propose_calibration', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: uploadedImage,
                        region: {
                            left_px: primaryRegion.left_px,
                            right_px: primaryRegion.right_px,
                            top_px: topPx,
                            bottom_px: bottomPx,
                        }
                    })
                });

                const data = await resp.json();
                if (!data.success) {
                    showStatus(`AI calibration failed: ${data.error || 'unknown error'}`, 'error');
                    return;
                }

                const calib = data.calibration || {};
                const depthAxis = calib.depth_axis || {};
                const tracks = calib.tracks || [];

                // Apply depth_axis
                if (Number.isFinite(depthAxis.top_pixel)) {
                    topPxInput.value = Math.round(depthAxis.top_pixel);
                }
                if (Number.isFinite(depthAxis.bottom_pixel)) {
                    bottomPxInput.value = Math.round(depthAxis.bottom_pixel);
                }
                if (Number.isFinite(depthAxis.top_depth)) {
                    document.getElementById('topDepth').value = depthAxis.top_depth;
                }
                if (Number.isFinite(depthAxis.bottom_depth)) {
                    document.getElementById('bottomDepth').value = depthAxis.bottom_depth;
                }

                // Apply tracks
                if (tracks.length > 0) {
                    const numCurvesInput = document.getElementById('numCurves');
                    numCurvesInput.value = Math.min(6, tracks.length);
                    generateCurveInputs();

                    for (let i = 0; i < Math.min(6, tracks.length); i++) {
                        const t = tracks[i];
                        if (Number.isFinite(t.left_x)) {
                            const leftPxEl = document.getElementById(`leftPx${i}`);
                            if (leftPxEl) leftPxEl.value = Math.round(t.left_x);
                        }
                        if (Number.isFinite(t.right_x)) {
                            const rightPxEl = document.getElementById(`rightPx${i}`);
                            if (rightPxEl) rightPxEl.value = Math.round(t.right_x);
                        }
                        if (Number.isFinite(t.scale_min)) {
                            const leftValEl = document.getElementById(`leftVal${i}`);
                            if (leftValEl) leftValEl.value = t.scale_min;
                        }
                        if (Number.isFinite(t.scale_max)) {
                            const rightValEl = document.getElementById(`rightVal${i}`);
                            if (rightValEl) rightValEl.value = t.scale_max;
                        }
                        if (t.name) {
                            const typeEl = document.getElementById(`type${i}`);
                            if (typeEl) {
                                const nameUpper = t.name.toUpperCase();
                                if (['GR', 'RHOB', 'NPHI', 'DT', 'CALI', 'SP'].includes(nameUpper)) {
                                    typeEl.value = nameUpper;
                                    syncCurveTypeToLabels(i);
                                }
                            }
                        }
                        if (t.color_hint) {
                            const modeEl = document.getElementById(`mode${i}`);
                            if (modeEl && ['black', 'red', 'blue', 'green'].includes(t.color_hint)) {
                                modeEl.value = t.color_hint;
                            }
                        }
                    }
                }

                renderDepthOverlays();
                renderPrimaryRegionOverlay();
                updateCurveScaleHints();
                showStatus(`‚úÖ AI calibration applied: ${tracks.length} tracks proposed. Review and adjust as needed.`, 'success');
            } catch (err) {
                showStatus(`AI calibration request failed: ${err.message}`, 'error');
            }
        }

        async function aiDetectTracks() {
            if (!uploadedImage || !imageWidth || !imageHeight) {
                showStatus('Please upload an image first.', 'info');
                return;
            }

            if (!primaryRegion || !Number.isFinite(primaryRegion.left_px) || !Number.isFinite(primaryRegion.right_px)) {
                showStatus('Please select a panel first (click "Select panel from image" and drag a box).', 'info');
                return;
            }

            const topPxInput = document.getElementById('topPx');
            const bottomPxInput = document.getElementById('bottomPx');
            const topPx = topPxInput ? parseFloat(topPxInput.value) : 0;
            const bottomPx = bottomPxInput ? parseFloat(bottomPxInput.value) : imageHeight - 1;

            if (!Number.isFinite(topPx) || !Number.isFinite(bottomPx) || bottomPx <= topPx) {
                showStatus('Invalid depth pixel range; please select a panel first.', 'info');
                return;
            }

            showStatus('‚è≥ Asking AI to detect tracks from header (Vision + LLM)...', 'info');

            try {
                const resp = await fetch('/api/auto_layout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: uploadedImage,
                        region: {
                            left_px: primaryRegion.left_px,
                            right_px: primaryRegion.right_px,
                            top_px: topPx,
                            bottom_px: bottomPx,
                        }
                    })
                });

                const data = await resp.json();
                if (!data.success) {
                    showStatus(`AI track detection failed: ${data.error || 'unknown error'}`, 'error');
                    clearTrackOverlays();
                    return;
                }

                const tracks = data.tracks || [];
                if (!tracks.length) {
                    showStatus('AI track detection returned no tracks.', 'info');
                    clearTrackOverlays();
                    return;
                }

                const numCurvesInput = document.getElementById('numCurves');
                numCurvesInput.value = Math.min(6, tracks.length);

                // generateCurveInputs can accept track [left, right] pairs
                const tracksForInputs = tracks.slice(0, 6).map(t => [Math.round(t.left_px), Math.round(t.right_px)]);
                generateCurveInputs(tracksForInputs);

                for (let i = 0; i < Math.min(6, tracks.length); i++) {
                    const t = tracks[i];

                    if (Number.isFinite(t.scale_min)) {
                        const leftValEl = document.getElementById(`leftVal${i}`);
                        if (leftValEl) leftValEl.value = t.scale_min;
                    }
                    if (Number.isFinite(t.scale_max)) {
                        const rightValEl = document.getElementById(`rightVal${i}`);
                        if (rightValEl) rightValEl.value = t.scale_max;
                    }
                    if (t.unit) {
                        const unitEl = document.getElementById(`unit${i}`);
                        const lasUnitEl = document.getElementById(`lasUnit${i}`);
                        if (unitEl) unitEl.value = t.unit;
                        if (lasUnitEl) lasUnitEl.value = t.unit;
                    }
                    if (t.name) {
                        const typeEl = document.getElementById(`type${i}`);
                        if (typeEl) {
                            const nameUpper = t.name.toUpperCase();
                            if (['GR', 'RHOB', 'NPHI', 'DT', 'CALI', 'SP'].includes(nameUpper)) {
                                typeEl.value = nameUpper;
                                syncCurveTypeToLabels(i);
                            }
                        }
                    }
                }

                renderDepthOverlays();
                renderPrimaryRegionOverlay();
                renderTrackOverlays(tracks);
                updateCurveScaleHints();
                showStatus(`‚úÖ AI detected ${tracks.length} track(s). Review and adjust as needed.`, 'success');
            } catch (err) {
                showStatus(`AI track detection request failed: ${err.message}`, 'error');
                clearTrackOverlays();
            }
        }

        function generateValidationReport() {
            const numCurvesInput = document.getElementById('numCurves');
            const numCurves = numCurvesInput ? (parseInt(numCurvesInput.value) || 0) : 0;
            if (numCurves === 0) return;

            const validationResults = [];
            
            for (let i = 0; i < numCurves; i++) {
                const typeEl = document.getElementById(`type${i}`);
                const nameEl = document.getElementById(`name${i}`);
                const lasMnemonicEl = document.getElementById(`lasMnemonic${i}`);
                
                if (!typeEl || !nameEl) continue;
                
                const curveType = typeEl.value;
                const displayName = nameEl.value.trim().toUpperCase();
                const lasMnemonic = lasMnemonicEl ? lasMnemonicEl.value.trim().toUpperCase() : '';
                
                // Check if display name matches curve type
                const typeMatch = displayName === curveType || displayName.includes(curveType);
                const mnemonicMatch = displayName === lasMnemonic;
                
                let confidence = 'unknown';
                let message = '';
                
                if (typeMatch && mnemonicMatch) {
                    confidence = 'high';
                    message = `‚úÖ High confidence: OCR label "${displayName}" matches curve type "${curveType}"`;
                } else if (typeMatch || mnemonicMatch) {
                    confidence = 'medium';
                    message = `‚ö†Ô∏è Medium confidence: Partial match between "${displayName}" and "${curveType}"`;
                } else if (displayName && displayName !== 'CURVE' + (i + 1)) {
                    confidence = 'low';
                    message = `‚ùå Low confidence: OCR label "${displayName}" doesn't match curve type "${curveType}"`;
                } else {
                    confidence = 'unknown';
                    message = `‚ùì No OCR label detected for Curve ${i + 1}`;
                }
                
                validationResults.push({
                    curveIndex: i + 1,
                    curveType,
                    displayName,
                    lasMnemonic,
                    confidence,
                    message
                });
            }
            
            // Display validation report
            displayValidationReport(validationResults);
        }

        function displayValidationReport(results) {
            const summaryEl = document.getElementById('curveScaleSummary');
            if (!summaryEl) return;
            
            const highConfidence = results.filter(r => r.confidence === 'high').length;
            const mediumConfidence = results.filter(r => r.confidence === 'medium').length;
            const lowConfidence = results.filter(r => r.confidence === 'low').length;
            
            let reportHtml = '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">';
            reportHtml += '<h4 style="margin-top: 0;">üîç AI Validation Report</h4>';
            reportHtml += `<p style="margin: 10px 0;"><strong>Summary:</strong> ${highConfidence} high confidence, ${mediumConfidence} medium, ${lowConfidence} low</p>`;
            reportHtml += '<div style="font-size: 0.9em;">';
            
            results.forEach(result => {
                const color = result.confidence === 'high' ? '#28a745' : 
                             result.confidence === 'medium' ? '#ffc107' : 
                             result.confidence === 'low' ? '#dc3545' : '#6c757d';
                reportHtml += `<div style="margin: 8px 0; padding: 8px; background: white; border-left: 4px solid ${color}; border-radius: 4px;">`;
                reportHtml += `<strong>Curve ${result.curveIndex}:</strong> ${result.message}`;
                reportHtml += '</div>';
            });
            
            reportHtml += '</div></div>';
            
            // Append to summary element
            const existingReport = summaryEl.querySelector('.validation-report');
            if (existingReport) {
                existingReport.remove();
            }
            const reportDiv = document.createElement('div');
            reportDiv.className = 'validation-report';
            reportDiv.innerHTML = reportHtml;
            summaryEl.appendChild(reportDiv);
        }

        function updateCurveScaleHints(autoApply) {
            const numCurvesInput = document.getElementById('numCurves');
            const summaryEl = document.getElementById('curveScaleSummary');
            const numCurves = numCurvesInput ? (parseInt(numCurvesInput.value) || 0) : 0;
            if (!summaryEl) {
                return;
            }

            const typeRanges = [
                { type: 'GR',   low: 0.0,   high: 200.0, label: 'GR (Gamma Ray, API)' },
                { type: 'RHOB', low: 1.7,   high: 3.0,   label: 'RHOB (Density, g/cc)' },
                { type: 'DT',   low: 40.0,  high: 200.0, label: 'DT/DTCO (Sonic, ¬µs/ft)' },
                { type: 'NPHI', low: 0.0,   high: 0.5,   label: 'NPHI (Neutron, v/v)' }
            ];

            function inferType(minVal, maxVal) {
                // Score by how much of the typical range is covered, to avoid
                // everything looking like GR when the scale is very narrow
                // (e.g. 1.95‚Äì2.95 should strongly prefer RHOB over GR).
                let bestType = null;
                let bestScore = 0;
                for (const tr of typeRanges) {
                    const ovLow = Math.max(minVal, tr.low);
                    const ovHigh = Math.min(maxVal, tr.high);
                    const overlap = ovHigh - ovLow;
                    if (overlap <= 0) continue;
                    const span = tr.high - tr.low;
                    const coverage = span > 0 ? (overlap / span) : 0;
                    const score = coverage;
                    if (score > bestScore) {
                        bestScore = score;
                        bestType = tr.type;
                    }
                }
                return bestType;
            }

            function describeType(t) {
                const found = typeRanges.find(tr => tr.type === t);
                return found ? found.label : t;
            }

            const summaries = [];

            for (let i = 0; i < numCurves; i++) {
                const hintEl = document.getElementById(`curveHint${i}`);
                const typeEl = document.getElementById(`type${i}`);
                const leftValEl = document.getElementById(`leftVal${i}`);
                const rightValEl = document.getElementById(`rightVal${i}`);
                if (!hintEl || !typeEl || !leftValEl || !rightValEl) {
                    continue;
                }

                const typeVal = (typeEl.value || '').toUpperCase();
                const leftVal = parseFloat(leftValEl.value);
                const rightVal = parseFloat(rightValEl.value);
                if (!Number.isFinite(leftVal) || !Number.isFinite(rightVal)) {
                    hintEl.innerHTML = '';
                    continue;
                }

                const minVal = Math.min(leftVal, rightVal);
                const maxVal = Math.max(leftVal, rightVal);
                const bestType = inferType(minVal, maxVal);

                summaries.push({ index: i + 1, selectedType: typeVal, bestType });

                if (!bestType) {
                    hintEl.innerHTML = 'Scale does not clearly match GR/RHOB/DT/NPHI typical ranges.';
                    continue;
                }

                const autoFix = !!autoApply;

                if (typeVal === bestType) {
                    hintEl.innerHTML = `‚úì Scale looks consistent with ${describeType(bestType)}.`;
                } else if (typeVal === 'OTHER' || !typeVal) {
                    if (autoFix) {
                        applySuggestedType(i, bestType, true);
                        hintEl.innerHTML = `Auto-selected ${describeType(bestType)} based on scale.`;
                    } else {
                        hintEl.innerHTML = `Scale looks like ${describeType(bestType)}; consider setting type to ${bestType}.`;
                    }
                } else {
                    if (autoFix) {
                        applySuggestedType(i, bestType, true);
                        hintEl.innerHTML = `Auto-corrected: was ${typeVal}, now ${bestType} (scale matched ${describeType(bestType)}).`;
                    } else {
                        // Warn but do not auto-change type; let the user decide
                        hintEl.innerHTML = `‚ö†Ô∏è Warning: type is ${typeVal} but scale looks like ${describeType(bestType)}. <button type="button" class="btn" style="padding: 4px 8px; font-size: 0.8em; margin-left: 4px;" onclick="applySuggestedType(${i}, '${bestType}')">Fix: switch to ${bestType}</button>`;
                    }
                }
            }

            // Simple GR/RHOB swap hint
            let swapMessage = '';
            const grAsRhob = summaries.filter(s => s.selectedType === 'GR' && s.bestType === 'RHOB');
            const rhobAsGr = summaries.filter(s => s.selectedType === 'RHOB' && s.bestType === 'GR');
            if (grAsRhob.length && rhobAsGr.length) {
                const a = grAsRhob[0].index;
                const b = rhobAsGr[0].index;
                swapMessage = `‚ö†Ô∏è Possible swap: curve ${a} looks like RHOB while curve ${b} looks like GR based on scale ranges.`;
            }

            summaryEl.textContent = swapMessage;
        }

        function generateCurveInputs(tracks = null) {
            const numCurves = parseInt(document.getElementById('numCurves').value);
            const container = document.getElementById('curvesContainer');
            container.innerHTML = '';

            const curveTypes = ['GR', 'RHOB', 'NPHI', 'DT', 'CALI', 'SP'];
            const displayNames = ['GR', 'RHOB', 'NPHI', 'DT', 'CALI', 'SP', 'RES', 'PERM'];
            const displayUnits = ['API', 'g/cc', 'v/v', 'us/ft', 'in', 'mV', 'ohmm', 'mD'];

            for (let i = 0; i < numCurves; i++) {
                const track = (tracks && tracks[i]) || (detectedTracks && detectedTracks[i]) || null;
                const hint = (ocrSuggestions && ocrSuggestions.curves && ocrSuggestions.curves[i]) || null;
                const leftPx = track ? track[0] : hint ? Math.round(hint.left_px) : Math.floor(imageWidth * (0.1 + i * 0.8 / numCurves));
                const rightPx = track ? track[1] : hint ? Math.round(hint.right_px) : Math.floor(imageWidth * (0.1 + (i + 1) * 0.8 / numCurves));

                // Use OCR label hint as the initial curve type when available
                const hintedType = hint && hint.label_type ? hint.label_type : null;
                const defaultType = hintedType || curveTypes[i] || 'GR';

                // Get OCR-detected display name independently (from label_text or label_mnemonic)
                const ocrDisplayName = hint && (hint.label_text || hint.label_mnemonic) ? 
                    (hint.label_text || hint.label_mnemonic) : null;

                // Build defaults for LAS mnemonic/unit: start from type defaults, then let OCR override
                let defaults = curveTypeDefaults[defaultType] || { mnemonic: defaultType, unit: '' };
                if (hint && hint.label_mnemonic) {
                    defaults = {
                        mnemonic: hint.label_mnemonic,
                        unit: hint.label_unit || defaults.unit || ''
                    };
                }

                // Decide default curve color:
                //  1) Use image-based color hint if available (blue/green/red/dark).
                //  2) Otherwise, fall back to a sensible guess from curve type
                //     so key curves like GR/DT get green/blue by default.
                let recommendedMode = hint && hint.color_recommended_mode ? hint.color_recommended_mode : null;
                if (!recommendedMode) {
                    if (defaultType === 'DT') {
                        recommendedMode = 'blue';
                    } else if (defaultType === 'GR') {
                        recommendedMode = 'green';
                    } else {
                        recommendedMode = (i === 0 ? 'red' : 'black');
                    }
                }

                const curveDiv = document.createElement('div');
                curveDiv.className = 'curve-config';
                curveDiv.innerHTML = `
                    <h3>Curve ${i + 1}</h3>
                    <div class="grid">
                        <div class="field">
                            <label for="type${i}">Curve type</label>
                            <select id="type${i}">
                                <option value="GR" ${defaultType === 'GR' ? 'selected' : ''}>GR (Gamma Ray)</option>
                                <option value="RHOB" ${defaultType === 'RHOB' ? 'selected' : ''}>RHOB (Density)</option>
                                <option value="NPHI" ${defaultType === 'NPHI' ? 'selected' : ''}>NPHI (Neutron)</option>
                                <option value="DT" ${defaultType === 'DT' ? 'selected' : ''}>DT / DTC (Sonic)</option>
                                <option value="CALI" ${defaultType === 'CALI' ? 'selected' : ''}>CALI (Caliper)</option>
                                <option value="SP" ${defaultType === 'SP' ? 'selected' : ''}>SP (Spontaneous Potential)</option>
                                <option value="OTHER" ${(defaultType !== 'GR' && defaultType !== 'RHOB' && defaultType !== 'NPHI' && defaultType !== 'DT' && defaultType !== 'CALI' && defaultType !== 'SP') ? 'selected' : ''}>Other</option>
                            </select>
                        </div>
                        <div class="field">
                            <label for="name${i}">Display name (optional)</label>
                            <input type="text" id="name${i}" placeholder="Label shown in app" value="${ocrDisplayName || displayNames[i] || 'CURVE' + (i + 1)}">
                        </div>
                        <div class="field">
                            <label for="unit${i}">Display unit (optional)</label>
                            <input type="text" id="unit${i}" placeholder="Display unit" value="${displayUnits[i] || ''}">
                        </div>
                        <div class="field">
                            <label for="leftPx${i}">Left pixel (X)</label>
                            <input type="number" id="leftPx${i}" placeholder="Left X" value="${leftPx}">
                        </div>
                        <div class="field">
                            <label for="rightPx${i}">Right pixel (X)</label>
                            <input type="number" id="rightPx${i}" placeholder="Right X" value="${rightPx}">
                        </div>
                        <div class="field">
                            <label for="leftVal${i}">Left scale value</label>
                            <input type="number" id="leftVal${i}" placeholder="Left value" step="0.01" value="${i === 0 ? 0 : i === 1 ? 1.95 : 0.45}">
                        </div>
                        <div class="field">
                            <label for="rightVal${i}">Right scale value</label>
                            <input type="number" id="rightVal${i}" placeholder="Right value" step="0.01" value="${i === 0 ? 150 : i === 1 ? 2.95 : -0.15}">
                        </div>
                        <div class="field">
                            <label for="mode${i}">Curve color / mode</label>
                            <select id="mode${i}">
                                <option value="black" ${recommendedMode === 'black' ? 'selected' : ''}>Black</option>
                                <option value="red" ${recommendedMode === 'red' ? 'selected' : ''}>Red</option>
                                <option value="blue" ${recommendedMode === 'blue' ? 'selected' : ''}>Blue</option>
                                <option value="green" ${recommendedMode === 'green' ? 'selected' : ''}>Green</option>
                            </select>
                        </div>
                        <div class="field">
                            <label>Advanced LAS label (optional)</label>
                            <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                                <input type="text" id="lasMnemonic${i}" placeholder="LAS mnemonic (e.g. GR, DTC)" value="${defaults.mnemonic}">
                                <input type="text" id="lasUnit${i}" placeholder="LAS unit (e.g. API, G/CC)" value="${defaults.unit}">
                            </div>
                        </div>
                        <div class="field">
                            <label>Scale check</label>
                            <div class="hint-text" id="curveHint${i}"></div>
                        </div>
                    </div>
                `;
                container.appendChild(curveDiv);

                const typeEl = document.getElementById(`type${i}`);
                const leftValEl = document.getElementById(`leftVal${i}`);
                const rightValEl = document.getElementById(`rightVal${i}`);
                
                // #1: Auto-sync type changes to LAS mnemonic/unit
                if (typeEl) {
                    typeEl.addEventListener('change', () => {
                        syncCurveTypeToLabels(i);
                        updateCurveScaleHints();
                    });
                }
                
                // #3: Re-infer type when scale changes
                [leftValEl, rightValEl].forEach((el) => {
                    if (el) {
                        el.addEventListener('change', updateCurveScaleHints);
                        el.addEventListener('input', updateCurveScaleHints);
                    }
                });
            }
            // One-time auto-application of inferred types right after fields
            // are generated, so the AI guess fills the dropdowns, but later
            // edits only show warnings and a Fix button.
            updateCurveScaleHints(true);
            // Generate validation report after curves are populated
            setTimeout(() => generateValidationReport(), 100);
        }

        function applyOcrSuggestions() {
            if (!ocrSuggestions) {
                return false;
            }

            let applied = false;
            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

            if (ocrSuggestions.depth) {
                const depthHint = ocrSuggestions.depth;
                const topPxInput = document.getElementById('topPx');
                const bottomPxInput = document.getElementById('bottomPx');
                const topDepthInput = document.getElementById('topDepth');
                const bottomDepthInput = document.getElementById('bottomDepth');

                if (topPxInput && Number.isFinite(depthHint.top_px)) {
                    topPxInput.value = Math.round(clamp(depthHint.top_px, 0, imageHeight - 1));
                    applied = true;
                }
                if (bottomPxInput && Number.isFinite(depthHint.bottom_px)) {
                    bottomPxInput.value = Math.round(clamp(depthHint.bottom_px, 0, imageHeight - 1));
                    applied = true;
                }
                if (topDepthInput && Number.isFinite(depthHint.top_depth)) {
                    topDepthInput.value = depthHint.top_depth;
                    applied = true;
                }
                if (bottomDepthInput && Number.isFinite(depthHint.bottom_depth)) {
                    bottomDepthInput.value = depthHint.bottom_depth;
                    applied = true;
                }
            }

            if (ocrSuggestions.curves && ocrSuggestions.curves.length) {
                const maxCurves = Math.min(6, ocrSuggestions.curves.length);
                for (let i = 0; i < maxCurves; i++) {
                    const hint = ocrSuggestions.curves[i];
                    const leftInput = document.getElementById(`leftPx${i}`);
                    const rightInput = document.getElementById(`rightPx${i}`);
                    if (hint && leftInput && Number.isFinite(hint.left_px)) {
                        leftInput.value = Math.round(clamp(hint.left_px, 0, imageWidth - 1));
                        applied = true;
                    }
                    if (hint && rightInput && Number.isFinite(hint.right_px)) {
                        rightInput.value = Math.round(clamp(hint.right_px, 0, imageWidth - 1));
                        applied = true;
                    }
                }
            }

            return applied;
        }

        function clearLabelOverlays() {
            const overlay = document.getElementById('overlay');
            if (!overlay) return;
            const markers = overlay.querySelectorAll('.label-overlay');
            markers.forEach((el) => el.remove());
        }

        function renderLabelOverlays() {
            const overlay = document.getElementById('overlay');
            const img = document.getElementById('imagePreview');
            if (!overlay || !img || !ocrSuggestions || !ocrSuggestions.curves || !ocrSuggestions.curves.length) {
                clearLabelOverlays();
                return;
            }

            const rect = img.getBoundingClientRect();
            if (!rect.width || !rect.height || !imageWidth || !imageHeight) {
                clearLabelOverlays();
                return;
            }

            const scaleX = rect.width / imageWidth;
            const scaleY = rect.height / imageHeight;

            clearLabelOverlays();

            ocrSuggestions.curves.forEach((hint) => {
                if (hint.label_text == null || hint.label_x == null || hint.label_y == null) {
                    return;
                }
                const x = hint.label_x * scaleX;
                const y = hint.label_y * scaleY;
                const marker = document.createElement('div');
                marker.className = 'label-overlay';
                marker.style.left = `${x - 6}px`;
                marker.style.top = `${y - 6}px`;
                const parts = [];
                parts.push(`AI saw "${hint.label_text}" here`);
                if (hint.label_mnemonic) {
                    parts.push(`suggesting ${hint.label_mnemonic}`);
                }
                marker.title = parts.join(' ‚Üí ');
                overlay.appendChild(marker);
            });
        }

        function clearPhraseHighlight() {
            const overlay = document.getElementById('overlay');
            if (!overlay) return;
            const boxes = overlay.querySelectorAll('.phrase-highlight');
            boxes.forEach((el) => el.remove());
        }

        function clearPrimaryRegionOverlay() {
            const overlay = document.getElementById('overlay');
            if (!overlay) return;
            const boxes = overlay.querySelectorAll('.primary-region-overlay, .panel-mask-overlay');
            boxes.forEach((el) => el.remove());
        }

        function renderPrimaryRegionOverlay() {
            const overlay = document.getElementById('overlay');
            const img = document.getElementById('imagePreview');
            if (!overlay || !img || !primaryRegion || !imageWidth || !imageHeight) {
                clearPrimaryRegionOverlay();
                return;
            }

            const rect = img.getBoundingClientRect();
            if (!rect.width || !rect.height) {
                clearPrimaryRegionOverlay();
                return;
            }

            const leftPx = Number(primaryRegion.left_px);
            const rightPx = Number(primaryRegion.right_px);
            if (!Number.isFinite(leftPx) || !Number.isFinite(rightPx) || rightPx <= leftPx) {
                clearPrimaryRegionOverlay();
                return;
            }

            clearPrimaryRegionOverlay();

            const denomX = Math.max(1, imageWidth - 1);
            const xDom = (leftPx / denomX) * rect.width;
            const xDomRight = (rightPx / denomX) * rect.width;
            const widthDom = xDomRight - xDom;

            // Vertical placement follows the same mapping as renderDepthOverlays
            let topDom = 0;
            let heightDom = rect.height;
            const cfg = typeof getDepthConfigFromInputs === 'function' ? getDepthConfigFromInputs() : null;
            if (cfg && Number.isFinite(cfg.top_px) && Number.isFinite(cfg.bottom_px) && cfg.bottom_px > cfg.top_px) {
                const scaleY = rect.height / imageHeight;
                topDom = cfg.top_px * scaleY;
                heightDom = (cfg.bottom_px - cfg.top_px) * scaleY;
            }

            // Nudge the top edge down slightly in screen space so the visible
            // border does not appear above the graph, while keeping the
            // bottom edge fixed. Use a small constant fudge tuned for the
            // preview size so the top border sits just above the grid without
            // cutting off too much.
            const topFudgePx = 20; // set to 20px as requested
            if (heightDom > topFudgePx) {
                topDom += topFudgePx;
                heightDom -= topFudgePx;
            }

            const box = document.createElement('div');
            box.className = 'primary-region-overlay';
            box.style.left = `${xDom}px`;
            box.style.top = `${topDom}px`;
            box.style.width = `${widthDom}px`;
            box.style.height = `${heightDom}px`;
            overlay.appendChild(box);

            const dragging = primaryRegionDrag && primaryRegionDrag.active && primaryRegionDrag.edge === 'marquee' && panelSelectMode;
            if (dragging) {
                return;
            }

            const makeMask = (left, top, width, height) => {
                if (width <= 0 || height <= 0) return;
                const m = document.createElement('div');
                m.className = 'panel-mask-overlay';
                m.style.left = `${left}px`;
                m.style.top = `${top}px`;
                m.style.width = `${width}px`;
                m.style.height = `${height}px`;
                overlay.appendChild(m);
            };

            makeMask(0, 0, rect.width, topDom);
            makeMask(0, topDom + heightDom, rect.width, rect.height - (topDom + heightDom));
            makeMask(0, topDom, xDom, heightDom);
            makeMask(xDom + widthDom, topDom, rect.width - (xDom + widthDom), heightDom);
        }

        function clearTrackOverlays() {
            const overlay = document.getElementById('overlay');
            if (!overlay) return;
            const boxes = overlay.querySelectorAll('.ai-track-overlay');
            boxes.forEach((el) => el.remove());
        }

        function renderTrackOverlays(trackBoxes) {
            const overlay = document.getElementById('overlay');
            const img = document.getElementById('imagePreview');
            if (!overlay || !img || !trackBoxes || !trackBoxes.length || !imageWidth || !imageHeight) {
                clearTrackOverlays();
                return;
            }

            const rect = img.getBoundingClientRect();
            if (!rect.width || !rect.height) {
                clearTrackOverlays();
                return;
            }
            const denomX = Math.max(1, imageWidth - 1);

            // Vertical band follows current depth config, using same mapping as renderDepthOverlays
            let topDom = 0;
            let heightDom = rect.height;
            const cfg = typeof getDepthConfigFromInputs === 'function' ? getDepthConfigFromInputs() : null;
            if (cfg && Number.isFinite(cfg.top_px) && Number.isFinite(cfg.bottom_px) && cfg.bottom_px > cfg.top_px) {
                const scaleY = rect.height / imageHeight;
                topDom = cfg.top_px * scaleY;
                heightDom = (cfg.bottom_px - cfg.top_px) * scaleY;
            }

            // Apply the same top-edge fudge as the primary region so
            // orange AI track boxes visually align with the blue panel box.
            const topFudgePx = 20;
            if (heightDom > topFudgePx) {
                topDom += topFudgePx;
                heightDom -= topFudgePx;
            }

            clearTrackOverlays();

            trackBoxes.forEach((t) => {
                const leftPx = Number(t.left_px);
                const rightPx = Number(t.right_px);
                if (!Number.isFinite(leftPx) || !Number.isFinite(rightPx) || rightPx <= leftPx) return;

                const xDom = (leftPx / denomX) * rect.width;
                const xDomRight = (rightPx / denomX) * rect.width;
                const widthDom = xDomRight - xDom;

                const box = document.createElement('div');
                box.className = 'ai-track-overlay';
                box.style.left = `${xDom}px`;
                box.style.top = `${topDom}px`;
                box.style.width = `${widthDom}px`;
                box.style.height = `${heightDom}px`;
                if (t.name) {
                    box.title = `AI track: ${t.name}`;
                }
                overlay.appendChild(box);
            });
        }

        function findPhraseRegionInOcr(phrase) {
            const rawPhrase = (phrase || '').trim();
            if (!rawPhrase) return null;

            const normPhrase = rawPhrase.toUpperCase().replace(/[^A-Z0-9]+/g, ' ').trim();
            if (!normPhrase) return null;

            // 1) Try AI label hints first (ocrSuggestions.curves.label_text / label_x / label_y)
            if (ocrSuggestions && Array.isArray(ocrSuggestions.curves)) {
                for (const hint of ocrSuggestions.curves) {
                    const labelText = (hint.label_text || '').toUpperCase();
                    const normLabel = labelText.replace(/[^A-Z0-9]+/g, ' ').trim();
                    if (!normLabel) continue;
                    if (normLabel.includes(normPhrase) || normPhrase.includes(normLabel)) {
                        const x = Number(hint.label_x);
                        const y = Number(hint.label_y);
                        if (Number.isFinite(x) && Number.isFinite(y)) {
                            // We only know a point; make a small box around it in image pixels
                            const boxWidth = Math.max(50, imageWidth * 0.1);
                            const boxHeight = Math.max(30, imageHeight * 0.03);
                            return {
                                x: Math.max(0, x - boxWidth / 2),
                                y: Math.max(0, y - boxHeight / 2),
                                width: boxWidth,
                                height: boxHeight
                            };
                        }
                    }
                }
            }

            // 2) Fallback: search raw Vision tokens more flexibly
            if (!detectedText || !detectedText.raw || !detectedText.raw.length) {
                return null;
            }

            const tokens = [];
            for (const ann of detectedText.raw) {
                const text = (ann.text || ann.description || '').trim();
                const verts = ann.vertices || (ann.bounding_poly && ann.bounding_poly.vertices) || [];
                if (!text || !verts || !verts.length) continue;
                tokens.push({
                    text: text.toUpperCase(),
                    verts: verts.map((v) => ({ x: Number(v.x) || 0, y: Number(v.y) || 0 }))
                });
            }

            if (!tokens.length) return null;

            const phraseTokens = normPhrase.split(/\s+/).filter(Boolean);
            const n = phraseTokens.length;
            if (!n) return null;

            function combineVerts(list) {
                const xs = [];
                const ys = [];
                for (const t of list) {
                    for (const p of t.verts) {
                        xs.push(p.x);
                        ys.push(p.y);
                    }
                }
                if (!xs.length || !ys.length) return null;
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const minY = Math.min(...ys);
                const maxY = Math.max(...ys);
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            for (let i = 0; i <= tokens.length - n; i++) {
                const windowTokens = tokens.slice(i, i + n);
                const joined = windowTokens.map((t) => t.text).join(' ');
                const normJoined = joined.replace(/[^A-Z0-9]+/g, ' ').trim();
                if (!normJoined) continue;
                if (normJoined === normPhrase || normJoined.includes(normPhrase) || normPhrase.includes(normJoined)) {
                    return combineVerts(windowTokens);
                }
            }

            return null;
        }

        function clearCurveTraceOverlays() {
            const overlay = document.getElementById('overlay');
            if (!overlay) return;
            const dots = overlay.querySelectorAll('.curve-trace-dot');
            dots.forEach((el) => el.remove());
        }

        function renderCurveTraceOverlays(curveTraces) {
            const overlay = document.getElementById('overlay');
            const img = document.getElementById('imagePreview');
            if (!overlay || !img || !curveTraces || !imageWidth || !imageHeight) {
                clearCurveTraceOverlays();
                return;
            }

            const rect = img.getBoundingClientRect();
            if (!rect.width || !rect.height) {
                clearCurveTraceOverlays();
                return;
            }

            const scaleX = rect.width / imageWidth;
            const scaleY = rect.height / imageHeight;

            clearCurveTraceOverlays();

            Object.keys(curveTraces).forEach((name) => {
                const points = curveTraces[name] || [];
                for (const pt of points) {
                    if (!Array.isArray(pt) || pt.length < 2) continue;
                    const xImg = pt[0];
                    const yImg = pt[1];
                    const xDom = xImg * scaleX;
                    const yDom = yImg * scaleY;
                    const dot = document.createElement('div');
                    dot.className = 'curve-trace-dot';
                    dot.style.left = `${xDom - 1}px`;
                    dot.style.top = `${yDom - 1}px`;
                    overlay.appendChild(dot);
                }
            });
        }

        function clearDepthOverlays() {
            const overlay = document.getElementById('overlay');
            if (!overlay) return;
            const lines = overlay.querySelectorAll('.depth-overlay-line, .ai-depth-hint-line, .ai-depth-hint-label');
            lines.forEach((el) => el.remove());
        }

        function renderDepthOverlays() {
            const overlay = document.getElementById('overlay');
            const img = document.getElementById('imagePreview');
            if (!overlay || !img || !imageWidth || !imageHeight) {
                clearDepthOverlays();
                return;
            }

            const cfg = getDepthConfigFromInputs();
            if (!cfg) {
                clearDepthOverlays();
                return;
            }

            const rect = img.getBoundingClientRect();
            if (!rect.height) {
                clearDepthOverlays();
                return;
            }

            clearDepthOverlays();

            const topPx = cfg.top_px;
            const bottomPx = cfg.bottom_px;
            const topDepth = cfg.top_depth;
            const bottomDepth = cfg.bottom_depth;

            const dMin = Math.min(topDepth, bottomDepth);
            const dMax = Math.max(topDepth, bottomDepth);
            const span = dMax - dMin;
            if (!Number.isFinite(span) || span <= 0) return;

            const pixSpan = bottomPx - topPx;
            if (!Number.isFinite(pixSpan) || pixSpan === 0) return;

            // Choose a "nice" step to target about 5‚Äì10 lines
            const targetLines = 8;
            let roughStep = span / targetLines;
            if (roughStep <= 0) return;
            const pow10 = Math.pow(10, Math.floor(Math.log10(roughStep)));
            const candidates = [1, 2, 5, 10];
            let bestStep = pow10;
            for (const c of candidates) {
                const s = c * pow10;
                if (Math.abs(s - roughStep) < Math.abs(bestStep - roughStep)) {
                    bestStep = s;
                }
            }

            const step = bestStep;
            const start = Math.ceil(dMin / step) * step;
            for (let depth = start; depth <= dMax + 1e-6; depth += step) {
                const t = (depth - topDepth) / (bottomDepth - topDepth);
                const yImg = topPx + t * pixSpan;
                if (!Number.isFinite(yImg)) continue;
                if (yImg < 0 || yImg > imageHeight - 1) continue;
                const yDom = (yImg / imageHeight) * rect.height;

                const line = document.createElement('div');
                line.className = 'depth-overlay-line';
                line.style.top = `${yDom}px`;

                const label = document.createElement('div');
                label.className = 'depth-overlay-label';
                label.textContent = depth.toFixed(0);
                line.appendChild(label);
                overlay.appendChild(line);
            }

            // Mark AI-guessed top/bottom pixels from OCR depth hint, if available
            if (ocrSuggestions && ocrSuggestions.depth) {
                const d = ocrSuggestions.depth;
                const addHint = (yPx, text) => {
                    if (!Number.isFinite(yPx)) return;
                    const yDom = (yPx / imageHeight) * rect.height;
                    const line = document.createElement('div');
                    line.className = 'depth-overlay-line ai-depth-hint-line';
                    line.style.top = `${yDom}px`;

                    const label = document.createElement('div');
                    label.className = 'depth-overlay-label ai-depth-hint-label';
                    label.textContent = text;
                    line.appendChild(label);
                    overlay.appendChild(line);
                };

                if (Number.isFinite(d.top_px)) {
                    const txt = Number.isFinite(d.top_depth)
                        ? `AI top ~${d.top_depth.toFixed(0)} (${Math.round(d.top_px)} px)`
                        : `AI top (${Math.round(d.top_px)} px)`;
                    addHint(d.top_px, txt);
                }
                if (Number.isFinite(d.bottom_px)) {
                    const txt = Number.isFinite(d.bottom_depth)
                        ? `AI bottom ~${d.bottom_depth.toFixed(0)} (${Math.round(d.bottom_px)} px)`
                        : `AI bottom (${Math.round(d.bottom_px)} px)`;
                    addHint(d.bottom_px, txt);
                }
            }
        }

        async function runDigitization() {
            const btn = document.getElementById('digitizeBtn');
            btn.disabled = true;
            showStatus('üîÑ Processing...', 'info');

            // Build config
            const config = {
                depth: {
                    top_px: parseInt(document.getElementById('topPx').value),
                    bottom_px: parseInt(document.getElementById('bottomPx').value),
                    top_depth: parseFloat(document.getElementById('topDepth').value),
                    bottom_depth: parseFloat(document.getElementById('bottomDepth').value),
                    unit: document.getElementById('depthUnit').value
                },
                global_options: {
                    downsample: 1,
                    blur: 3,
                    min_run: 2,
                    smooth_window: 5,
                    null: -999.25
                },
                curves: []
            };

            const numCurves = parseInt(document.getElementById('numCurves').value);
            for (let i = 0; i < numCurves; i++) {
                const type = document.getElementById(`type${i}`).value;
                const displayName = document.getElementById(`name${i}`).value;
                const displayUnit = document.getElementById(`unit${i}`).value;
                const lasMnemonicInput = document.getElementById(`lasMnemonic${i}`).value.trim();
                const lasUnitInput = document.getElementById(`lasUnit${i}`).value.trim();

                const defaults = curveTypeDefaults[type] || {};
                const lasMnemonic = lasMnemonicInput || (defaults.mnemonic || (displayName ? displayName.toUpperCase() : `CURVE${i + 1}`));
                const lasUnit = lasUnitInput || (defaults.unit || displayUnit);

                config.curves.push({
                    type: type,
                    display_name: displayName,
                    display_unit: displayUnit,
                    name: lasMnemonic,
                    unit: lasUnit,
                    las_mnemonic: lasMnemonic,
                    las_unit: lasUnit,
                    left_px: parseInt(document.getElementById(`leftPx${i}`).value),
                    right_px: parseInt(document.getElementById(`rightPx${i}`).value),
                    left_value: parseFloat(document.getElementById(`leftVal${i}`).value),
                    right_value: parseFloat(document.getElementById(`rightVal${i}`).value),
                    mode: document.getElementById(`mode${i}`).value
                });
            }

            try {
                saveDepthConfigToSession();
                renderDepthOverlays();
                const response = await fetch('/digitize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: uploadedImage,
                        config: config,
                        detected_text: detectedText || null
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Store digitized data for cursor readout
                    lastDigitizedDepth = Array.isArray(data.digitized_depth) ? data.digitized_depth : null;
                    lastDigitizedCurves = data.digitized_curves || null;

                    // Download LAS file
                    const blob = new Blob([data.las_content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = data.filename;
                    a.click();
                    URL.revokeObjectURL(url);

                    let statusType = 'success';
                    let message;
                    if (data.validation && data.validation.passed) {
                        message = `‚úÖ LAS file downloaded. ${data.validation.message}`;
                    } else if (data.validation) {
                        statusType = 'info';
                        message = `‚ö†Ô∏è LAS saved, but validation reported: ${data.validation.message}`;
                    } else {
                        message = '‚úÖ Success! LAS file downloaded.';
                    }

                    if (data.depth_warnings && data.depth_warnings.length) {
                        const joinedDepth = data.depth_warnings.join(' | ');
                        message += ` ‚ö†Ô∏è Depth sanity warnings: ${joinedDepth}`;
                        if (statusType === 'success') {
                            statusType = 'info';
                        }
                    }

                    if (data.outlier_warnings && data.outlier_warnings.length) {
                        const joined = data.outlier_warnings.join(' | ');
                        message += ` ‚ö†Ô∏è Curve sanity warnings: ${joined}`;
                        if (statusType === 'success') {
                            statusType = 'info';
                        }
                    }

                    if (data.curve_traces) {
                        renderCurveTraceOverlays(data.curve_traces);
                    } else {
                        clearCurveTraceOverlays();
                    }

                    if (data.ai_payload) {
                        window.lastAiPayload = data.ai_payload;
                    }

                    if (data.ai_summary) {
                        const insightsStep = document.getElementById('insightsStep');
                        const panel = document.getElementById('aiInsightContent');
                        insightsStep.classList.remove('hidden');
                        const existing = panel.innerHTML || '';
                        const aiBlock = `
                            <div class="insight-block">
                                <h3>ü§ñ AI Curve Analysis & Methodology</h3>
                                <div class="hint-text" style="white-space: pre-wrap;">${data.ai_summary}</div>
                            </div>
                        `;
                        panel.innerHTML = existing + aiBlock;
                    }

                    showStatus(message, statusType);
                } else {
                    showStatus('‚ùå Error during digitization', 'error');
                }
            } catch (error) {
                showStatus('‚ùå Error: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        function showStatus(message, type) {
            const statusArea = document.getElementById('statusArea');
            statusArea.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function scrollToBottom() {
            window.scrollTo({
                top: document.body.scrollHeight,
                behavior: 'smooth'
            });
        }

        function jumpToOcrMatch(index) {
            if (!ocrSearchMatches || !ocrSearchMatches.length) return;
            if (index < 0 || index >= ocrSearchMatches.length) return;

            const match = ocrSearchMatches[index];
            const vertices = match.vertices;

            const img = document.getElementById('imagePreview');
            const overlay = document.getElementById('overlay');

            if (!img || !overlay || !imageWidth || !imageHeight) {
                showStatus('Image preview not available.', 'info');
                return;
            }

            const centerX = vertices.reduce((sum, v) => sum + (v.x || 0), 0) / vertices.length;
            const centerY = vertices.reduce((sum, v) => sum + (v.y || 0), 0) / vertices.length;

            const scaleX = img.clientWidth / imageWidth;
            const scaleY = img.clientHeight / imageHeight;

            const imgRect = img.getBoundingClientRect();
            const scrollX = imgRect.left + (centerX * scaleX) - window.innerWidth / 2;
            const scrollY = imgRect.top + (centerY * scaleY) - window.innerHeight / 2;

            window.scrollTo({
                left: scrollX + window.scrollX,
                top: scrollY + window.scrollY,
                behavior: 'smooth'
            });

            const existingHighlight = document.getElementById('ocrHighlight');
            if (existingHighlight) {
                existingHighlight.remove();
            }

            const highlight = document.createElement('div');
            highlight.id = 'ocrHighlight';
            highlight.style.position = 'absolute';
            highlight.style.border = '3px solid yellow';
            highlight.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
            highlight.style.pointerEvents = 'none';
            highlight.style.zIndex = '1000';

            const minX = Math.min(...vertices.map(v => v.x || 0));
            const minY = Math.min(...vertices.map(v => v.y || 0));
            const maxX = Math.max(...vertices.map(v => v.x || 0));
            const maxY = Math.max(...vertices.map(v => v.y || 0));

            highlight.style.left = `${minX * scaleX}px`;
            highlight.style.top = `${minY * scaleY}px`;
            highlight.style.width = `${(maxX - minX) * scaleX}px`;
            highlight.style.height = `${(maxY - minY) * scaleY}px`;

            overlay.appendChild(highlight);

            // Remove highlight after 3 seconds
            setTimeout(() => {
                if (highlight.parentNode) {
                    highlight.remove();
                }
            }, 3000);

            const labelText = match.text || '';
            showStatus(`Found "${labelText}" (${index + 1} of ${ocrSearchMatches.length}) at pixel (${Math.round(centerX)}, ${Math.round(centerY)})`, 'success');
        }

        function handlePhraseSearch() {
            const input = document.getElementById('phraseSearch');
            if (!input) return;
            
            const phrase = input.value.trim().toLowerCase();
            if (!phrase) {
                showStatus('Please enter a label to search for.', 'info');
                return;
            }

            if (!detectedText || !detectedText.raw || detectedText.raw.length === 0) {
                showStatus('‚ö†Ô∏è OCR not available. Google Vision API credentials need to be configured on the server.', 'info');
                return;
            }

            const matches = [];
            for (const annotation of detectedText.raw) {
                if (!annotation.text || !annotation.vertices) {
                    continue;
                }
                const text = annotation.text.toLowerCase();

                if (text.includes(phrase) || phrase.includes(text)) {
                    matches.push(annotation);
                }
            }

            if (!matches.length) {
                ocrSearchMatches = [];
                ocrSearchIndex = -1;
                ocrSearchPhrase = phrase;
                showStatus(`Label "${phrase}" not found in OCR text.`, 'info');
                return;
            }

            ocrSearchMatches = matches;
            ocrSearchPhrase = phrase;
            ocrSearchIndex = 0;
            jumpToOcrMatch(ocrSearchIndex);
        }

        const phraseSearchInput = document.getElementById('phraseSearch');
        if (phraseSearchInput) {
            phraseSearchInput.addEventListener('keydown', function (event) {
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    if (!ocrSearchMatches || !ocrSearchMatches.length) {
                        return;
                    }
                    event.preventDefault();
                    if (event.key === 'ArrowDown') {
                        ocrSearchIndex = (ocrSearchIndex + 1) % ocrSearchMatches.length;
                    } else {
                        ocrSearchIndex = (ocrSearchIndex - 1 + ocrSearchMatches.length) % ocrSearchMatches.length;
                    }
                    jumpToOcrMatch(ocrSearchIndex);
                }
            });
        }

        async function askAiAboutLog() {
            const textarea = document.getElementById('aiChatQuestion');
            const output = document.getElementById('aiChatOutput');
            if (!textarea || !output) return;

            const question = textarea.value.trim();
            if (!question) {
                showStatus('Please type a question for the AI about this log.', 'info');
                return;
            }

            // Check if we have ai_payload from a previous digitization
            if (!window.lastAiPayload) {
                output.innerHTML = '<p class="hint-text">‚ö†Ô∏è Please digitize a log first (click "Digitize & Download LAS") before asking AI questions.</p>';
                showStatus('Please digitize a log first before using AI chat.', 'info');
                return;
            }

            try {
                output.innerHTML = '<p class="hint-text">Asking AI...</p>';
                const resp = await fetch('/ask_ai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ai_payload: window.lastAiPayload,
                        question: question
                    })
                });
                const data = await resp.json();
                if (!data.success) {
                    output.innerHTML = `<p class="hint-text">AI error: ${data.error || 'unknown error'}</p>`;
                    return;
                }
                output.innerHTML = `<div class="hint-text" style="white-space: pre-wrap;">${data.answer}</div>`;
            } catch (err) {
                output.innerHTML = `<p class="hint-text">AI request failed: ${err.message}</p>`;
            }
        }

        async function askAiWhichCurveIsWhich() {
            const textarea = document.getElementById('aiChatQuestion');
            if (!textarea) return;
            textarea.value = 'Please list each LAS curve in this log and state which petrophysical curve type it most likely is (GR, RHOB, NPHI, DT, RES, CALI, SP, etc.), with brief reasoning. Also mention any obvious mislabeling or swapped curves.';
            await askAiAboutLog();
        }

        function parseLas(lasText) {
            const lines = lasText.split(/\r?\n/);
            const curveOrder = [];
            const curveValues = {};
            const depth = [];
            let depthName = 'DEPTH';
            let inCurveSection = false;
            let inAsciiSection = false;

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) continue;

                if (line.startsWith('~')) {
                    const upper = line.toUpperCase();
                    inCurveSection = upper.startsWith('~CURVE');
                    inAsciiSection = upper.startsWith('~ASCII') || upper.startsWith('~A');
                    continue;
                }

                if (inCurveSection) {
                    const match = line.match(/^([A-Za-z0-9_]+)\./);
                    if (match) {
                        const name = match[1].toUpperCase();
                        if (!curveOrder.includes(name)) {
                            curveOrder.push(name);
                            curveValues[name] = [];
                        }
                    }
                    continue;
                }

                if (inAsciiSection) {
                    const parts = line.split(/\s+/).map(Number);
                    if (parts.some((p) => Number.isNaN(p))) {
                        continue;
                    }
                    if (curveOrder.length === 0 || parts.length < curveOrder.length) {
                        continue;
                    }
                    depth.push(parts[0]);
                    curveOrder.forEach((name, idx) => {
                        if (idx === 0) {
                            depthName = name;
                            return;
                        }
                        curveValues[name].push(parts[idx]);
                    });
                }
            }

            if (!depth.length || curveOrder.length <= 1) {
                return null;
            }

            const curves = curveOrder
                .slice(1)
                .map((name) => ({ name, values: curveValues[name] || [] }));

            return { depth, depthName, curves };
        }

        function renderAiInsights() {
            const insightsStep = document.getElementById('insightsStep');
            const panel = document.getElementById('aiInsightContent');
            insightsStep.classList.remove('hidden');

            if (!ocrSuggestions || (!ocrSuggestions.depth && !(ocrSuggestions.curves && ocrSuggestions.curves.length))) {
                panel.innerHTML = '<p>AI hints were not confident enough to suggest values for this image.</p>';
                return;
            }

            const parts = [];

            if (ocrSuggestions.depth) {
                const d = ocrSuggestions.depth;
                parts.push(`
                    <div class="insight-block">
                        <h3>Depth Scale</h3>
                        <ul>
                            <li>Top pixel ‚âà <strong>${Math.round(d.top_px)}</strong></li>
                            <li>Bottom pixel ‚âà <strong>${Math.round(d.bottom_px)}</strong></li>
                            <li>Top depth ‚âà <strong>${d.top_depth}</strong></li>
                            <li>Bottom depth ‚âà <strong>${d.bottom_depth}</strong></li>
                        </ul>
                    </div>
                `);
            }

            if (ocrSuggestions.curves && ocrSuggestions.curves.length) {
                const list = ocrSuggestions.curves
                    .slice(0, 6)
                    .map((hint, idx) => {
                        const baseLine = `Curve ${idx + 1}: pixels ${Math.round(hint.left_px)} ‚Üí ${Math.round(hint.right_px)}${
                            hint.sample_value !== undefined ? ` (sample value ‚âà ${hint.sample_value.toFixed(2)})` : ''
                        }`;

                        let labelLine = '';
                        if (hint.label_type || hint.label_mnemonic || hint.label_text) {
                            const parts = [];
                            if (hint.label_type) {
                                parts.push(`type <strong>${hint.label_type}</strong>`);
                            }
                            if (hint.label_mnemonic && hint.label_mnemonic !== hint.label_type) {
                                parts.push(`mnemonic <strong>${hint.label_mnemonic}</strong>`);
                            }
                            if (hint.label_text) {
                                parts.push(`text "${hint.label_text}"`);
                            }
                            labelLine = `<br><span class="hint-text">AI saw ${parts.join(', ')} near this track.</span>`;
                        }
                        let colorLine = '';
                        if (hint.color_hint_text) {
                            colorLine = `<br><span class="hint-text">${hint.color_hint_text}</span>`;
                        }

                        return `<li>${baseLine}${labelLine}${colorLine}</li>`;
                    })
                    .join('');
                parts.push(`
                    <div class="insight-block">
                        <h3>Curve Tracks</h3>
                        <ul>${list}</ul>
                    </div>
                `);
            }

            panel.innerHTML = parts.join('');
        }
    </script>
</body>
</html>
